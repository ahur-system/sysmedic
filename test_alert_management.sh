#!/bin/bash

# SysMedic Alert Management Test Script
# Tests all alert management functionality for v1.0.3

set -e  # Exit on any error

echo "🔍 SysMedic Alert Management Test Suite v1.0.3"
echo "================================================"
echo

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Test counter
TESTS_PASSED=0
TESTS_TOTAL=0

# Function to run a test
run_test() {
    local test_name="$1"
    local test_command="$2"
    local expected_pattern="$3"

    TESTS_TOTAL=$((TESTS_TOTAL + 1))
    echo -e "${BLUE}Test $TESTS_TOTAL: $test_name${NC}"

    # Run the command and capture output
    if output=$(eval "$test_command" 2>&1); then
        if [[ -z "$expected_pattern" ]] || echo "$output" | grep -q "$expected_pattern"; then
            echo -e "  ${GREEN}✓ PASSED${NC}"
            TESTS_PASSED=$((TESTS_PASSED + 1))
            if [[ ! -z "$expected_pattern" ]]; then
                echo "    Expected pattern found: $expected_pattern"
            fi
        else
            echo -e "  ${RED}✗ FAILED${NC}"
            echo "    Expected pattern: $expected_pattern"
            echo "    Actual output:"
            echo "$output" | sed 's/^/    /'
        fi
    else
        echo -e "  ${RED}✗ FAILED (Command failed)${NC}"
        echo "    Output:"
        echo "$output" | sed 's/^/    /'
    fi
    echo
}

# Function to check if sysmedic binary exists
check_binary() {
    if [[ ! -f "./sysmedic" ]]; then
        echo -e "${RED}Error: sysmedic binary not found!${NC}"
        echo "Please run: go build -o sysmedic ./cmd/sysmedic"
        exit 1
    fi
}

# Function to start daemon if not running
ensure_daemon_running() {
    echo -e "${YELLOW}Ensuring SysMedic daemon is running...${NC}"

    # Check if daemon is already running
    if ./sysmedic daemon status 2>/dev/null | grep -q "running"; then
        echo -e "${GREEN}Daemon is already running${NC}"
    else
        echo "Starting daemon..."
        ./sysmedic daemon start
        sleep 3  # Give daemon time to start

        # Verify it started
        if ./sysmedic daemon status 2>/dev/null | grep -q "running"; then
            echo -e "${GREEN}Daemon started successfully${NC}"
        else
            echo -e "${RED}Failed to start daemon${NC}"
            exit 1
        fi
    fi
    echo
}

# Function to generate some test alerts
generate_test_alerts() {
    echo -e "${YELLOW}Generating test alerts by running daemon for a short period...${NC}"

    # Let daemon run for a few seconds to potentially generate alerts
    sleep 5

    echo -e "${GREEN}Test alerts should be generated by normal daemon operation${NC}"
    echo
}

# Function to stop daemon
cleanup_daemon() {
    echo -e "${YELLOW}Cleaning up daemon...${NC}"
    if ./sysmedic daemon status 2>/dev/null | grep -q "running"; then
        ./sysmedic daemon stop
        echo -e "${GREEN}Daemon stopped${NC}"
    fi
    echo
}

# Main test execution
main() {
    echo "Starting SysMedic Alert Management Tests..."
    echo

    # Pre-test checks
    check_binary

    # Test 1: Version check
    run_test "Version Check" "./sysmedic --version" "1.0.3"

    # Test 2: Help for alerts command
    run_test "Alerts Help Command" "./sysmedic alerts --help" "View, resolve, and manage"

    # Test 3: List alerts help
    run_test "Alerts List Help" "./sysmedic alerts list --help" "Show only unresolved alerts"

    # Test 4: Resolve alert help
    run_test "Alerts Resolve Help" "./sysmedic alerts resolve --help" "Resolve a specific alert by ID"

    # Test 5: Resolve all alerts help
    run_test "Alerts Resolve All Help" "./sysmedic alerts resolve-all --help" "Resolve all unresolved alerts"

    # Start daemon and generate some test data
    ensure_daemon_running
    generate_test_alerts

    # Test 6: Show alerts overview
    run_test "Show Alerts Overview" "./sysmedic alerts" "Alert Summary"

    # Test 7: List all alerts
    run_test "List All Alerts" "./sysmedic alerts list" "Total:"

    # Test 8: List only unresolved alerts
    run_test "List Unresolved Alerts" "./sysmedic alerts list -u" "Status"

    # Test 9: List alerts for different periods
    run_test "List Alerts (7 days)" "./sysmedic alerts list -p 7d" "Last 7d"

    # Test 10: Test invalid alert ID resolution
    run_test "Resolve Invalid Alert ID" "./sysmedic alerts resolve 99999" "not found"

    # Test 11: Test invalid alert ID format
    run_test "Resolve Invalid Alert Format" "./sysmedic alerts resolve abc" "Invalid alert ID"

    # Test 12: Dashboard shows alert information
    run_test "Dashboard Alert Info" "./sysmedic" "System:"

    # Test 13: Reports include alert information
    run_test "Reports Include Alerts" "./sysmedic reports" "Recent Alerts\\|No alerts"

    # Test 14: Test resolve-all with no confirmation
    run_test "Resolve All - Cancel" "echo 'n' | ./sysmedic alerts resolve-all" "Operation cancelled"

    # Test 15: Configuration shows alert-related settings
    run_test "Configuration Display" "./sysmedic config show" "CPU Threshold\\|Memory Threshold"

    # Advanced tests (if alerts exist)
    echo -e "${BLUE}Advanced Alert Management Tests${NC}"
    echo "======================================"

    # Check if there are any alerts to work with
    alert_count=$(./sysmedic alerts list -u 2>/dev/null | grep -c "^[0-9]" || echo "0")

    if [[ $alert_count -gt 0 ]]; then
        # Get the first alert ID
        first_alert_id=$(./sysmedic alerts list -u 2>/dev/null | grep "^[0-9]" | head -1 | awk '{print $1}')

        if [[ ! -z "$first_alert_id" ]]; then
            # Test 16: Resolve a specific alert
            run_test "Resolve Specific Alert" "./sysmedic alerts resolve $first_alert_id" "resolved successfully"

            # Test 17: Try to resolve the same alert again
            run_test "Resolve Already Resolved Alert" "./sysmedic alerts resolve $first_alert_id" "already resolved"
        fi

        # Test 18: Resolve all remaining alerts
        remaining_count=$(./sysmedic alerts list -u 2>/dev/null | grep -c "^[0-9]" || echo "0")
        if [[ $remaining_count -gt 0 ]]; then
            run_test "Resolve All Alerts" "echo 'y' | ./sysmedic alerts resolve-all" "Successfully resolved"
        else
            echo -e "${YELLOW}No unresolved alerts remaining for resolve-all test${NC}"
        fi
    else
        echo -e "${YELLOW}No alerts found for advanced testing${NC}"
        echo "This is normal if the system is not under load"
    fi

    # Test 19: Test with no unresolved alerts
    run_test "No Unresolved Alerts" "./sysmedic alerts resolve-all" "No unresolved alerts found"

    # Clean up
    cleanup_daemon

    # Test summary
    echo
    echo "========================================"
    echo -e "${BLUE}Test Summary${NC}"
    echo "========================================"
    echo "Tests Passed: $TESTS_PASSED"
    echo "Tests Total:  $TESTS_TOTAL"

    if [[ $TESTS_PASSED -eq $TESTS_TOTAL ]]; then
        echo -e "${GREEN}🎉 All tests passed!${NC}"
        echo
        echo -e "${GREEN}✅ Alert Management Features Working Correctly:${NC}"
        echo "   • Alert overview and summary"
        echo "   • List alerts with filtering options"
        echo "   • Resolve individual alerts by ID"
        echo "   • Resolve all alerts with confirmation"
        echo "   • Error handling for invalid inputs"
        echo "   • Integration with dashboard and reports"
        exit 0
    else
        failed=$((TESTS_TOTAL - TESTS_PASSED))
        echo -e "${RED}❌ $failed test(s) failed${NC}"
        exit 1
    fi
}

# Display usage information
usage() {
    echo "Usage: $0 [options]"
    echo
    echo "Options:"
    echo "  -h, --help     Show this help message"
    echo "  -q, --quiet    Run tests quietly (minimal output)"
    echo
    echo "This script tests all SysMedic alert management functionality."
    echo "Make sure to build the sysmedic binary first:"
    echo "  go build -o sysmedic ./cmd/sysmedic"
    echo
}

# Parse command line arguments
case "${1:-}" in
    -h|--help)
        usage
        exit 0
        ;;
    -q|--quiet)
        # Redirect output for quiet mode
        exec > /dev/null 2>&1
        ;;
esac

# Run the main test suite
main
